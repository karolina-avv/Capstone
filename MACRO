import numpy as np
import matplotlib.pyplot as plt

# Parameters
alpha = 1/3       # Output elasticity of capital
s = 0.2           # Savings rate
delta = 0.05      # Depreciation rate
A_initial = 2.0   # Initial Total Factor Productivity
t_shock = 20      # Time of TFP shock
A_shock = 2.0     # TFP after shock (10% increase)
T = 100           # Total time
dt = 0.1          # Time step
N = int(T / dt)   # Number of time steps

# Time array
time = np.linspace(0, T, N)

# Initialize arrays
K = np.zeros(N)
Y = np.zeros(N)
I = np.zeros(N)
D = np.zeros(N)
Net_I = np.zeros(N)
A = np.full(N, A_initial)

# Apply TFP shock at time t_shock
shock_index = int(t_shock / dt)
A[shock_index:] = A_shock

# Steady state capital stock before shock
K_ss_initial = ((s * A_initial) / delta) ** (1 / (1 - alpha))
Y_ss_initial = A_initial * K_ss_initial ** alpha

# Steady state capital stock after shock
K_ss_new = ((s * A_shock) / delta) ** (1 / (1 - alpha))
Y_ss_new = A_shock * K_ss_new ** alpha

# Initialize capital at steady state
K[0] = K_ss_initial

# Simulate the model over time
for t in range(N - 1):
    Y[t] = A[t] * K[t] ** alpha         # Output
    I[t] = s * Y[t]                     # Investment
    D[t] = delta * K[t]                 # Depreciation
    Net_I[t] = I[t] - D[t]              # Net Investment
    # Update capital stock
    K[t + 1] = K[t] + dt * (Net_I[t])

# Calculate variables at the last time step
Y[-1] = A[-1] * K[-1] ** alpha
I[-1] = s * Y[-1]
D[-1] = delta * K[-1]
Net_I[-1] = I[-1] - D[-1]

# Plot the capital-output graph with shifts
K_values = np.linspace(0, K_ss_new * 1.2, 500)

# Output and investment curves before shock
Y_values_initial = A_initial * K_values ** alpha
Investment_curve_initial = s * Y_values_initial

# Output and investment curves after shock
Y_values_new = A_shock * K_values ** alpha
Investment_curve_new = s * Y_values_new

# Depreciation curve
Depreciation_curve = delta * K_values

plt.figure(figsize=(10, 6))
plt.plot(K_values, Y_values_initial, label='Output before Shock ($Y$)', linestyle='--')
plt.plot(K_values, Investment_curve_initial, label='Investment before Shock ($sY$)', linestyle='--')
plt.plot(K_values, Y_values_new, label='Output after Shock ($Y$)')
plt.plot(K_values, Investment_curve_new, label='Investment after Shock ($sY$)')
plt.plot(K_values, Depreciation_curve, label='Depreciation ($\delta K$)')
plt.scatter(K_ss_initial, delta * K_ss_initial, color='black', label='Initial Steady State')
plt.scatter(K_ss_new, delta * K_ss_new, color='red', label='New Steady State')

plt.xlabel('Capital ($K$)')
plt.ylabel('Output / Investment / Depreciation')
plt.title('Solow Growth Model: Capital vs Output')
plt.legend()
plt.grid(True)
plt.show()

# Plot time series graphs using subplots
variables = {
    'Capital Stock ($K$)': K,
    'Output ($Y$)': Y,
    'Investment ($I$)': I,
    'Depreciation ($\delta K$)': D,
    'Net Investment ($I - \delta K$)': Net_I
}

fig, axs = plt.subplots(3, 2, figsize=(15, 10))  # Create a 3x2 grid of subplots
axs = axs.flatten()  # Flatten the array to easily index

for idx, (var_name, var_data) in enumerate(variables.items()):
    axs[idx].plot(time, var_data)
    axs[idx].axvline(x=t_shock, color='red', linestyle='--', label='TFP Shock')
    axs[idx].set_xlabel('Time')
    axs[idx].set_ylabel(var_name)
    axs[idx].set_title(f'Time Series of {var_name}')
    axs[idx].legend()
    axs[idx].grid(True)

# Remove any empty subplots if variables are less than the number of subplots
if len(variables) < len(axs):
    for idx in range(len(variables), len(axs)):
        fig.delaxes(axs[idx])

plt.tight_layout()
plt.show()